// Code generated by sqlc. DO NOT EDIT.
// source: pages.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const getPage = `-- name: GetPage :one
SELECT status, type, available_from, available_to, title, description, translation_id, id, collectable_type, published_time, usergroups, tags FROM admin.page
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPage(ctx context.Context, id int64) (AdminPage, error) {
	row := q.db.QueryRowContext(ctx, getPage, id)
	var i AdminPage
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.TranslationID,
		&i.ID,
		&i.CollectableType,
		&i.PublishedTime,
		&i.Usergroups,
		&i.Tags,
	)
	return i, err
}

const getPageTranslations = `-- name: GetPageTranslations :many
SELECT id, language_code, page_id, title, description from public.page_t
`

func (q *Queries) GetPageTranslations(ctx context.Context) ([]PageT, error) {
	rows, err := q.db.QueryContext(ctx, getPageTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PageT
	for rows.Next() {
		var i PageT
		if err := rows.Scan(
			&i.ID,
			&i.LanguageCode,
			&i.PageID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPages = `-- name: GetPages :many
SELECT status, type, available_from, available_to, title, description, translation_id, id, collectable_type, published_time, usergroups, tags FROM admin.page
`

func (q *Queries) GetPages(ctx context.Context) ([]AdminPage, error) {
	rows, err := q.db.QueryContext(ctx, getPages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminPage
	for rows.Next() {
		var i AdminPage
		if err := rows.Scan(
			&i.Status,
			&i.Type,
			&i.AvailableFrom,
			&i.AvailableTo,
			&i.Title,
			&i.Description,
			&i.TranslationID,
			&i.ID,
			&i.CollectableType,
			&i.PublishedTime,
			&i.Usergroups,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPage = `-- name: InsertPage :one
WITH c AS (
    INSERT INTO collectable (
        type,
        available_from,
        available_to,
        published_time,
        status
    ) VALUES (
        'page',
        $1,
        $2,
        $3,
        $4
    ) RETURNING id, type, available_from, available_to, status, created_at, updated_at, published_time
),
p as (
    INSERT INTO page (
        id,
        collectable_type
    ) SELECT
        c.id,
        c.type
    FROM c RETURNING id, collectable_type
),
t AS (
    INSERT INTO page_t (
        page_id,
        language_code,
        title,
        description
    ) SELECT 
        c.id,
        'no',
        $5,
        $6
    FROM c RETURNING id, language_code, page_id, title, description
)
SELECT 
    c.status,
    c.type,
    c.published_time,
    c.available_from,
    c.available_to,
	t.title,
	t.description,
	t.id as translation_id,
    p.id, p.collectable_type
    FROM c,t,p
`

type InsertPageParams struct {
	AvailableFrom null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo   null_v4.Time   `db:"available_to" json:"availableTo"`
	PublishedTime null_v4.Time   `db:"published_time" json:"publishedTime"`
	Status        int16          `db:"status" json:"status"`
	Title         null_v4.String `db:"title" json:"title"`
	Description   null_v4.String `db:"description" json:"description"`
}

type InsertPageRow struct {
	Status          int16          `db:"status" json:"status"`
	Type            null_v4.String `db:"type" json:"type"`
	PublishedTime   null_v4.Time   `db:"published_time" json:"publishedTime"`
	AvailableFrom   null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo     null_v4.Time   `db:"available_to" json:"availableTo"`
	Title           null_v4.String `db:"title" json:"title"`
	Description     null_v4.String `db:"description" json:"description"`
	TranslationID   int64          `db:"translation_id" json:"translationID"`
	ID              int64          `db:"id" json:"id"`
	CollectableType null_v4.String `db:"collectable_type" json:"collectableType"`
}

func (q *Queries) InsertPage(ctx context.Context, arg InsertPageParams) (InsertPageRow, error) {
	row := q.db.QueryRowContext(ctx, insertPage,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.PublishedTime,
		arg.Status,
		arg.Title,
		arg.Description,
	)
	var i InsertPageRow
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.PublishedTime,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.TranslationID,
		&i.ID,
		&i.CollectableType,
	)
	return i, err
}

const upsertPage = `-- name: UpsertPage :one
WITH c AS (
    UPDATE collectable c1
    SET
        available_from = $3,
        available_to = $4,
        published_time = $5,
        status = $6
    WHERE c1.id = $7
    RETURNING c1.id, c1.type, c1.available_from, c1.available_to, c1.status, c1.created_at, c1.updated_at, c1.published_time
),
t AS (
    INSERT INTO page_t (
        page_id,
        language_code,
        title,
        description
    ) SELECT 
        $7,
        'no',
        $8,
        $9
    ON CONFLICT (page_id, language_code)
        DO UPDATE SET
            title = $8,
            description = $9
    RETURNING id, language_code, page_id, title, description
),
p as (
    SELECT id, collectable_type from page
    WHERE id = $7
),
ug_del AS (
    DELETE FROM usergroup_collectable
    where collectable_id=$7 and usergroup_id not in (select ug.id from unnest($1::text[]) as ug(id))
),
ug_ins AS (
    INSERT INTO usergroup_collectable(usergroup_id, collectable_id)
    select ug.id, $7
    from unnest($1::text[]) as ug(id)
        ON CONFLICT (usergroup_id, collectable_id) DO NOTHING
),
tg_del AS (
    DELETE FROM tag_collectable
    where collectable_id=$7 and tag_id not in (select tg.id from unnest($2::bigint[]) as tg(id))
),
tg_ins AS (
    INSERT INTO tag_collectable(tag_id, collectable_id)
    select tg.id, $7
    from unnest($2::bigint[]) as tg(id)
    ON CONFLICT (tag_id, collectable_id) DO NOTHING
)
SELECT 
    p.id, p.collectable_type,
    c.id, c.type, c.available_from, c.available_to, c.status, c.created_at, c.updated_at, c.published_time,
    $1::text[] as usergroups,
    $2::bigint[] as tags,
	t.title,
	t.description
    FROM c,t,p
`

type UpsertPageParams struct {
	Usergroups    []string       `db:"usergroups" json:"usergroups"`
	Tags          []int64        `db:"tags" json:"tags"`
	AvailableFrom null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo   null_v4.Time   `db:"available_to" json:"availableTo"`
	PublishedTime null_v4.Time   `db:"published_time" json:"publishedTime"`
	Status        int16          `db:"status" json:"status"`
	ID            int64          `db:"id" json:"id"`
	Title         null_v4.String `db:"title" json:"title"`
	Description   null_v4.String `db:"description" json:"description"`
}

type UpsertPageRow struct {
	ID              int64          `db:"id" json:"id"`
	CollectableType null_v4.String `db:"collectable_type" json:"collectableType"`
	ID_2            int64          `db:"id_2" json:"id2"`
	Type            null_v4.String `db:"type" json:"type"`
	AvailableFrom   null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo     null_v4.Time   `db:"available_to" json:"availableTo"`
	Status          int16          `db:"status" json:"status"`
	CreatedAt       time.Time      `db:"created_at" json:"createdAt"`
	UpdatedAt       time.Time      `db:"updated_at" json:"updatedAt"`
	PublishedTime   null_v4.Time   `db:"published_time" json:"publishedTime"`
	Usergroups      []string       `db:"usergroups" json:"usergroups"`
	Tags            []int64        `db:"tags" json:"tags"`
	Title           null_v4.String `db:"title" json:"title"`
	Description     null_v4.String `db:"description" json:"description"`
}

func (q *Queries) UpsertPage(ctx context.Context, arg UpsertPageParams) (UpsertPageRow, error) {
	row := q.db.QueryRowContext(ctx, upsertPage,
		pq.Array(arg.Usergroups),
		pq.Array(arg.Tags),
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.PublishedTime,
		arg.Status,
		arg.ID,
		arg.Title,
		arg.Description,
	)
	var i UpsertPageRow
	err := row.Scan(
		&i.ID,
		&i.CollectableType,
		&i.ID_2,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedTime,
		pq.Array(&i.Usergroups),
		pq.Array(&i.Tags),
		&i.Title,
		&i.Description,
	)
	return i, err
}
