// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"time"

	null_v4 "gopkg.in/guregu/null.v4"
)

const getAllMedias = `-- name: GetAllMedias :many
SELECT status, type, available_from, available_to, title, description, long_description, image_id, translation_id, id, collectable_type, media_type, primary_group_id, subclipped_media_id, reference_media_id, sequence_number, start_time, end_time, asset_id, agerating, created_at, updated_at FROM media_collectable
ORDER BY name
`

func (q *Queries) GetAllMedias(ctx context.Context) ([]MediaCollectable, error) {
	rows, err := q.db.QueryContext(ctx, getAllMedias)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaCollectable
	for rows.Next() {
		var i MediaCollectable
		if err := rows.Scan(
			&i.Status,
			&i.Type,
			&i.AvailableFrom,
			&i.AvailableTo,
			&i.Title,
			&i.Description,
			&i.LongDescription,
			&i.ImageID,
			&i.TranslationID,
			&i.ID,
			&i.CollectableType,
			&i.MediaType,
			&i.PrimaryGroupID,
			&i.SubclippedMediaID,
			&i.ReferenceMediaID,
			&i.SequenceNumber,
			&i.StartTime,
			&i.EndTime,
			&i.AssetID,
			&i.Agerating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedia = `-- name: GetMedia :one
SELECT status, type, available_from, available_to, title, description, long_description, image_id, translation_id, id, collectable_type, media_type, primary_group_id, subclipped_media_id, reference_media_id, sequence_number, start_time, end_time, asset_id, agerating, created_at, updated_at FROM media_collectable
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMedia(ctx context.Context, id int64) (MediaCollectable, error) {
	row := q.db.QueryRowContext(ctx, getMedia, id)
	var i MediaCollectable
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.LongDescription,
		&i.ImageID,
		&i.TranslationID,
		&i.ID,
		&i.CollectableType,
		&i.MediaType,
		&i.PrimaryGroupID,
		&i.SubclippedMediaID,
		&i.ReferenceMediaID,
		&i.SequenceNumber,
		&i.StartTime,
		&i.EndTime,
		&i.AssetID,
		&i.Agerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMedia = `-- name: InsertMedia :one
WITH c AS (
    INSERT INTO collectable (
        type,
        available_from,
        available_to,
        status
    ) VALUES (
        'media',
        $1,
        $2,
        $3
    ) RETURNING id, type, available_from, available_to, status, created_at, updated_at
),
m AS (
    INSERT INTO media (
        id,
        collectable_type,
        media_type,
        primary_group_id,
        subclipped_media_id,
        reference_media_id,
        sequence_number,
        start_time,
        end_time,
        asset_id,
        agerating
    ) SELECT
        c.id,
        c.type,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    FROM c RETURNING id, collectable_type, media_type, primary_group_id, subclipped_media_id, reference_media_id, sequence_number, start_time, end_time, asset_id, agerating, created_at, updated_at
),
t AS (
    INSERT INTO media_t (
        media_id,
        language_code,
        title,
        description,
        long_description
    ) SELECT 
        c.id,
        'no',
        $13,
        $14,
        $15
    FROM c RETURNING id, media_id, language_code, title, description, long_description, image_id
)
SELECT 
    c.status,
    c.type,
    c.available_from,
    c.available_to,
	t.title,
	t.description,
	t.long_description,
	t.image_id,
	t.id as translation_id,
    m.id, m.collectable_type, m.media_type, m.primary_group_id, m.subclipped_media_id, m.reference_media_id, m.sequence_number, m.start_time, m.end_time, m.asset_id, m.agerating, m.created_at, m.updated_at
    FROM c,t,m
`

type InsertMediaParams struct {
	AvailableFrom     null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo       null_v4.Time   `db:"available_to" json:"availableTo"`
	Status            int16          `db:"status" json:"status"`
	MediaType         null_v4.String `db:"media_type" json:"mediaType"`
	PrimaryGroupID    null_v4.Int    `db:"primary_group_id" json:"primaryGroupID"`
	SubclippedMediaID null_v4.Int    `db:"subclipped_media_id" json:"subclippedMediaID"`
	ReferenceMediaID  null_v4.Int    `db:"reference_media_id" json:"referenceMediaID"`
	SequenceNumber    int16          `db:"sequence_number" json:"sequenceNumber"`
	StartTime         null_v4.Float  `db:"start_time" json:"startTime"`
	EndTime           null_v4.Float  `db:"end_time" json:"endTime"`
	AssetID           null_v4.Int    `db:"asset_id" json:"assetID"`
	Agerating         null_v4.String `db:"agerating" json:"agerating"`
	Title             null_v4.String `db:"title" json:"title"`
	Description       null_v4.String `db:"description" json:"description"`
	LongDescription   null_v4.String `db:"long_description" json:"longDescription"`
}

type InsertMediaRow struct {
	Status            int16          `db:"status" json:"status"`
	Type              null_v4.String `db:"type" json:"type"`
	AvailableFrom     null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo       null_v4.Time   `db:"available_to" json:"availableTo"`
	Title             null_v4.String `db:"title" json:"title"`
	Description       null_v4.String `db:"description" json:"description"`
	LongDescription   null_v4.String `db:"long_description" json:"longDescription"`
	ImageID           null_v4.Int    `db:"image_id" json:"imageID"`
	TranslationID     int64          `db:"translation_id" json:"translationID"`
	ID                int64          `db:"id" json:"id"`
	CollectableType   null_v4.String `db:"collectable_type" json:"collectableType"`
	MediaType         null_v4.String `db:"media_type" json:"mediaType"`
	PrimaryGroupID    null_v4.Int    `db:"primary_group_id" json:"primaryGroupID"`
	SubclippedMediaID null_v4.Int    `db:"subclipped_media_id" json:"subclippedMediaID"`
	ReferenceMediaID  null_v4.Int    `db:"reference_media_id" json:"referenceMediaID"`
	SequenceNumber    int16          `db:"sequence_number" json:"sequenceNumber"`
	StartTime         null_v4.Float  `db:"start_time" json:"startTime"`
	EndTime           null_v4.Float  `db:"end_time" json:"endTime"`
	AssetID           null_v4.Int    `db:"asset_id" json:"assetID"`
	Agerating         null_v4.String `db:"agerating" json:"agerating"`
	CreatedAt         time.Time      `db:"created_at" json:"createdAt"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) InsertMedia(ctx context.Context, arg InsertMediaParams) (InsertMediaRow, error) {
	row := q.db.QueryRowContext(ctx, insertMedia,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.Status,
		arg.MediaType,
		arg.PrimaryGroupID,
		arg.SubclippedMediaID,
		arg.ReferenceMediaID,
		arg.SequenceNumber,
		arg.StartTime,
		arg.EndTime,
		arg.AssetID,
		arg.Agerating,
		arg.Title,
		arg.Description,
		arg.LongDescription,
	)
	var i InsertMediaRow
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.LongDescription,
		&i.ImageID,
		&i.TranslationID,
		&i.ID,
		&i.CollectableType,
		&i.MediaType,
		&i.PrimaryGroupID,
		&i.SubclippedMediaID,
		&i.ReferenceMediaID,
		&i.SequenceNumber,
		&i.StartTime,
		&i.EndTime,
		&i.AssetID,
		&i.Agerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMedia = `-- name: UpdateMedia :one
WITH c AS (
    UPDATE collectable c1
    SET
        available_from = $1,
        available_to = $2,
        status = $3
    WHERE c1.id = $4
    RETURNING c1.id, c1.type, c1.available_from, c1.available_to, c1.status, c1.created_at, c1.updated_at
),
m AS (
    UPDATE media m1
    SET
        /* media_type,
        primary_group_id,
        subclipped_media_id,
        reference_media_id,
        sequence_number,
        start_time,
        end_time,
        asset_id, */
        agerating = $5
    FROM c
    WHERE m1.id = c.id
    RETURNING m1.id, m1.collectable_type, m1.media_type, m1.primary_group_id, m1.subclipped_media_id, m1.reference_media_id, m1.sequence_number, m1.start_time, m1.end_time, m1.asset_id, m1.agerating, m1.created_at, m1.updated_at
),
t AS (
    UPDATE media_t t1
    SET
        title = $6,
        description = $7,
        long_description = $8
    FROM c
    WHERE t1.media_id = c.id AND t1.language_code = 'no'
    RETURNING t1.id, t1.media_id, t1.language_code, t1.title, t1.description, t1.long_description, t1.image_id
)
SELECT 
    c.status,
    c.type,
    c.available_from,
    c.available_to,
	t.title,
	t.description,
	t.long_description,
	t.image_id,
    m.id, m.collectable_type, m.media_type, m.primary_group_id, m.subclipped_media_id, m.reference_media_id, m.sequence_number, m.start_time, m.end_time, m.asset_id, m.agerating, m.created_at, m.updated_at
    FROM c,t,m
`

type UpdateMediaParams struct {
	AvailableFrom   null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo     null_v4.Time   `db:"available_to" json:"availableTo"`
	Status          int16          `db:"status" json:"status"`
	ID              int64          `db:"id" json:"id"`
	Agerating       null_v4.String `db:"agerating" json:"agerating"`
	Title           null_v4.String `db:"title" json:"title"`
	Description     null_v4.String `db:"description" json:"description"`
	LongDescription null_v4.String `db:"long_description" json:"longDescription"`
}

type UpdateMediaRow struct {
	Status            int16          `db:"status" json:"status"`
	Type              null_v4.String `db:"type" json:"type"`
	AvailableFrom     null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo       null_v4.Time   `db:"available_to" json:"availableTo"`
	Title             null_v4.String `db:"title" json:"title"`
	Description       null_v4.String `db:"description" json:"description"`
	LongDescription   null_v4.String `db:"long_description" json:"longDescription"`
	ImageID           null_v4.Int    `db:"image_id" json:"imageID"`
	ID                int64          `db:"id" json:"id"`
	CollectableType   null_v4.String `db:"collectable_type" json:"collectableType"`
	MediaType         null_v4.String `db:"media_type" json:"mediaType"`
	PrimaryGroupID    null_v4.Int    `db:"primary_group_id" json:"primaryGroupID"`
	SubclippedMediaID null_v4.Int    `db:"subclipped_media_id" json:"subclippedMediaID"`
	ReferenceMediaID  null_v4.Int    `db:"reference_media_id" json:"referenceMediaID"`
	SequenceNumber    int16          `db:"sequence_number" json:"sequenceNumber"`
	StartTime         null_v4.Float  `db:"start_time" json:"startTime"`
	EndTime           null_v4.Float  `db:"end_time" json:"endTime"`
	AssetID           null_v4.Int    `db:"asset_id" json:"assetID"`
	Agerating         null_v4.String `db:"agerating" json:"agerating"`
	CreatedAt         time.Time      `db:"created_at" json:"createdAt"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (UpdateMediaRow, error) {
	row := q.db.QueryRowContext(ctx, updateMedia,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.Status,
		arg.ID,
		arg.Agerating,
		arg.Title,
		arg.Description,
		arg.LongDescription,
	)
	var i UpdateMediaRow
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.LongDescription,
		&i.ImageID,
		&i.ID,
		&i.CollectableType,
		&i.MediaType,
		&i.PrimaryGroupID,
		&i.SubclippedMediaID,
		&i.ReferenceMediaID,
		&i.SequenceNumber,
		&i.StartTime,
		&i.EndTime,
		&i.AssetID,
		&i.Agerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMedia = `-- name: UpsertMedia :one
WITH c AS (
    UPDATE collectable c1
    SET
        available_from = $1,
        available_to = $2,
        status = $3
    WHERE c1.id = $4
    RETURNING c1.id, c1.type, c1.available_from, c1.available_to, c1.status, c1.created_at, c1.updated_at
),
m AS (
    UPDATE media m1
    SET
        /* media_type,
        primary_group_id,
        subclipped_media_id,
        reference_media_id,
        sequence_number,
        start_time,
        end_time,
        asset_id, */
        agerating = $5
    FROM c
    WHERE m1.id = c.id
    RETURNING m1.id, m1.collectable_type, m1.media_type, m1.primary_group_id, m1.subclipped_media_id, m1.reference_media_id, m1.sequence_number, m1.start_time, m1.end_time, m1.asset_id, m1.agerating, m1.created_at, m1.updated_at
),
t AS (
    INSERT INTO media_t (
        media_id,
        language_code,
        title,
        description,
        long_description
    ) SELECT 
        c.id,
        'no',
        $6,
        $7,
        $8
    FROM c
    ON CONFLICT (media_id, language_code)
        DO UPDATE SET
            title = $6,
            description = $7,
            long_description = $8
    RETURNING id, media_id, language_code, title, description, long_description, image_id
)
SELECT 
    c.status,
    c.type,
    c.available_from,
    c.available_to,
	t.title,
	t.description,
	t.long_description,
	t.image_id,
    m.id, m.collectable_type, m.media_type, m.primary_group_id, m.subclipped_media_id, m.reference_media_id, m.sequence_number, m.start_time, m.end_time, m.asset_id, m.agerating, m.created_at, m.updated_at
    FROM c,t,m
`

type UpsertMediaParams struct {
	AvailableFrom   null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo     null_v4.Time   `db:"available_to" json:"availableTo"`
	Status          int16          `db:"status" json:"status"`
	ID              int64          `db:"id" json:"id"`
	Agerating       null_v4.String `db:"agerating" json:"agerating"`
	Title           null_v4.String `db:"title" json:"title"`
	Description     null_v4.String `db:"description" json:"description"`
	LongDescription null_v4.String `db:"long_description" json:"longDescription"`
}

type UpsertMediaRow struct {
	Status            int16          `db:"status" json:"status"`
	Type              null_v4.String `db:"type" json:"type"`
	AvailableFrom     null_v4.Time   `db:"available_from" json:"availableFrom"`
	AvailableTo       null_v4.Time   `db:"available_to" json:"availableTo"`
	Title             null_v4.String `db:"title" json:"title"`
	Description       null_v4.String `db:"description" json:"description"`
	LongDescription   null_v4.String `db:"long_description" json:"longDescription"`
	ImageID           null_v4.Int    `db:"image_id" json:"imageID"`
	ID                int64          `db:"id" json:"id"`
	CollectableType   null_v4.String `db:"collectable_type" json:"collectableType"`
	MediaType         null_v4.String `db:"media_type" json:"mediaType"`
	PrimaryGroupID    null_v4.Int    `db:"primary_group_id" json:"primaryGroupID"`
	SubclippedMediaID null_v4.Int    `db:"subclipped_media_id" json:"subclippedMediaID"`
	ReferenceMediaID  null_v4.Int    `db:"reference_media_id" json:"referenceMediaID"`
	SequenceNumber    int16          `db:"sequence_number" json:"sequenceNumber"`
	StartTime         null_v4.Float  `db:"start_time" json:"startTime"`
	EndTime           null_v4.Float  `db:"end_time" json:"endTime"`
	AssetID           null_v4.Int    `db:"asset_id" json:"assetID"`
	Agerating         null_v4.String `db:"agerating" json:"agerating"`
	CreatedAt         time.Time      `db:"created_at" json:"createdAt"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) UpsertMedia(ctx context.Context, arg UpsertMediaParams) (UpsertMediaRow, error) {
	row := q.db.QueryRowContext(ctx, upsertMedia,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.Status,
		arg.ID,
		arg.Agerating,
		arg.Title,
		arg.Description,
		arg.LongDescription,
	)
	var i UpsertMediaRow
	err := row.Scan(
		&i.Status,
		&i.Type,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.Title,
		&i.Description,
		&i.LongDescription,
		&i.ImageID,
		&i.ID,
		&i.CollectableType,
		&i.MediaType,
		&i.PrimaryGroupID,
		&i.SubclippedMediaID,
		&i.ReferenceMediaID,
		&i.SequenceNumber,
		&i.StartTime,
		&i.EndTime,
		&i.AssetID,
		&i.Agerating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
